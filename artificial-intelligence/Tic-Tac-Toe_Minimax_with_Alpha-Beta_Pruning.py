from pade.core.agent import Agent
from pade.acl.messages import ACLMessage
from pade.acl.aid import AID
from pade.misc.utility import display_message, start_loop, call_later

from math import inf
import itertools
import random
import copy


class TicTacToe:
    def __init__(self):
        self.order = 3
        self.players = ['X', 'O']
        self.winner = None
        
        self.board = [
            [' ', ' ', ' '],
            [' ', ' ', ' '],
            [' ', ' ', ' ']
        ]
        
        self.empty_positions = [i for i in range(1, self.order * self.order + 1)]
        #print(self.empty_positions)
        
        XO_dict = {'X' : 0, 'O' : 0}
        self.sums = {
            'row' : [XO_dict.copy() for i in range(self.order)],
            'col' : [XO_dict.copy() for i in range(self.order)],
            'diag': XO_dict.copy(),
            'anti': XO_dict.copy()
        }
        
    def print_board(self):
        print(" --- --- --- ")
        for row in self.board:
            print(f"| {row[0]} | {row[1]} | {row[2]} |")
            print(" --- --- --- ")
    
    def print_board_positions(self):
        b = copy.deepcopy(self.board)
        row = 0
        col = 0

        for (i, j) in list(itertools.product(range(0, self.order), range(0, self.order))):
            pos_int = i * self.order + j + 1
            b[i][j] = pos_int
        
        print(" --- --- --- ")
        for row in b:
            print(f"| {row[0]} | {row[1]} | {row[2]} |")
            print(" --- --- --- ")
    
    def is_winner(self, player, pos):
        row = (pos-1) // ttt.order
        col = (pos-1) % ttt.order
        # check winner
        if (self.sums['row'][row][player] == self.order or self.sums['col'][col][player] == self.order or
            self.sums['diag'][player] == self.order or self.sums['anti'][player] == self.order):
            return True
        
        return False
    
    def make_move(self, player, pos):
        #position = self.board_pos[pos]
        #row, col = position
        row = (pos-1) // ttt.order
        col = (pos-1) % ttt.order
        if (self.board[row][col] != ' '):
            print("Can't play this move since position is already taken.")
            return False
        
        self.board[row][col] = player
        self.empty_positions.remove(pos)
        
        self.sums['row'][row][player] += 1
        self.sums['col'][col][player] += 1
        
        if (row == col):
            self.sums['diag'][player] += 1
        if (row + col == self.order-1):
            self.sums['anti'][player] += 1
        
        return True
    
    def undo_move(self, player, pos):
        row = (pos-1) // ttt.order
        col = (pos-1) % ttt.order
        if (self.board[row][col] == ' '):
            print("Can't undo this move since position is empty.")
            return False
        
        self.board[row][col] = ' '
        self.empty_positions.append(pos)
        
        self.sums['row'][row][player] -= 1
        self.sums['col'][col][player] -= 1
        
        if (row == col):
            self.sums['diag'][player] -= 1
        if (row + col == self.order-1):
            self.sums['anti'][player] -= 1
        
        return True


# # Tic-Tac-Toe as a search problem
# 
# TTT is a game with two players, MAX (X) and MIN (O). MAX moves first.
# 
# * `state`: represented by board
# 
# * `initial state`: empty board
# 
# * `possible_actions(state)`: list of legal moves in the state - i.e., the empty positions in the board
# 
# * `result(state, action)`: successor state generated by the action at the state, i.e., the resulting board after the action (move) has been made.
# 
# * `terminal_test(state)`: true if state is a leaf (game is over)
# 
# * `utility(state, player)`: final value for a game that ends in leaf state for a player p. Since MAX player moves first, only the utility values from the PoV of MAX will be used.
#     
#     * if MAX wins at s, utility(s) = 1,
#     
#     * if MIN wins at s, utility(s) = -1,
#     
#     * if game ties at s, utility(s) = 0

utilities = {
    'X' : 1,
    'O' : -1,
    'tie': 0
}


def terminal_state(ttt, player, pos):
    utility = None
    if (ttt.is_winner(player, pos)):
        utility = utilities[player]
    elif (ttt.empty_positions == []):
        utility = utilities['tie']
    return utility


def minimax_value(ttt, isMAX, alpha, beta, prev_player, prev_pos):
    if (isMAX):
        # current player is MAX (X)
        v = -inf
        player = 'X'
        
        for pos in ttt.empty_positions:
            ttt.make_move(player, pos)
            
            utility = terminal_state(ttt, player, pos)
            if (utility != None):
                ttt.undo_move(player, pos)
                return utility
            
            # next move is to be made by MIN, so isMAX = False
            v_poss = minimax_value(ttt, False, alpha, beta, player, pos)
            
            ttt.undo_move(player, pos)
            
            # current (maximizing) player will try to maximize the values returned
            v = max(v, v_poss)
            
            # MAX updates its alpha
            alpha = max(alpha, v)
            if (alpha >= beta):
                # MIN has a move where it can have a score v <= beta, which
                # is less than alpha, so, MIN will choose that move instead.
                # beta cutoff
                break
        return v
    else:
        # current player is MIN (O)
        v = inf
        player = 'O'
        
        for pos in ttt.empty_positions:
            ttt.make_move(player, pos)

            utility = terminal_state(ttt, player, pos)
            if (utility != None):
                ttt.undo_move(player, pos)
                return utility
            
            # next move is to be made by MAX, so isMAX = False
            v_poss = minimax_value(ttt, True, alpha, beta, player, pos)
            
            ttt.undo_move(player, pos)
            
            # current (minimizing) player will try to minimize the values returned
            v = min(v, v_poss)
            
            # MIN updates beta
            beta = min(beta, v)
            if (beta <= alpha):
                # MAX has a move where it can have a score v >= alpha, which
                # is more than beta, so, MAX will choose that move instead.
                # alpha cutoff
                break
        return v


def minimax_decision(ttt, player='X'):
    # decision from the PoV of MAX
    maximum = -inf
    maximizing_move = None
    
    # maintain the minimum score that the maximizing player is assured of
    alpha = -inf
    
    # maintain the maximum score that the minimizing player is assured of
    beta = inf
    
    for pos in ttt.empty_positions:
        # try making a move at this position
        ttt.make_move(player, pos)
        
        # check if making this move finishes the game
        # if yes, return the utility
        utility = terminal_state(ttt, player, pos)
        if (utility != None):
            ttt.undo_move(player, pos)
            return (pos, utility)
        
        # otherwise, choose the maximum of the possible scores of MIN
        v = minimax_value(ttt, False, alpha, beta, player, pos)
        
        # undo the move
        ttt.undo_move(player, pos)
        
        # record the maximum score possible
        # and the move that achieved it
        if(v > maximum):
            maximum = v
            maximizing_move = pos
        
        # since the root node is a MAX node,
        # it updates its alpha
        alpha = max(alpha, v)
            
    return (maximizing_move, maximum)


class HumanAgent(Agent):
    def __init__(self, aid):
        super().__init__(aid=aid)

    def decide_move(self):
        pos = int(input("Enter the position (1-9) to make move on: "))
        return pos


class ComputerAgent(Agent):
    def __init__(self, aid, idx, ttt):
        super().__init__(aid=aid)
        self.idx = idx
        self.ttt = ttt
        self.current_player = self.ttt.players[idx]
        self.opponent_player = self.ttt.players[idx ^ 1]
    
    def decide_move(self, idx):
        # use minimax to choose a decision (move)

        pos, _ = minimax_decision(ttt)
        #print("pos: ", pos)
        return pos

def start_playing(ttt):
    # convention : X goes first
    # if human is X, then human goes first; otherwise, computer
    
    idx = 0
    ask = """Who goes first (1-2)?\n1. Human\n2. Computer\nWhoever goes first will be the 'X' player: """
    goes_first = int(input(ask))
    if (goes_first == 1):
        human = ttt.players[idx] # X
        computer = ttt.players[idx ^ 1] # O
    else:
        human = ttt.players[idx ^ 1] # O
        computer = ttt.players[idx] # X
    
    port = 20000
    human_agent = HumanAgent(AID(name=f'human@localhost:{port}'))
    computer_agent = ComputerAgent(AID(name=f'computer@localhost:{port+10}'), idx ^ 1, ttt)
    
    turn = 1
    
    while (turn <= ttt.order * ttt.order):
        current_player = ttt.players[idx]
        
        print(f"\n=> Turn {turn}: player {current_player}'s turn")
        
        if current_player == human:
            pos = human_agent.decide_move()
            
        else:
            # computer with artificial "intelligence"
            pos = computer_agent.decide_move(idx)
            
        print(f'Player {current_player} is making move at position {pos}...')
        
        if (ttt.make_move(current_player, pos) == False):
            continue
        else:
            turn += 1
            #ttt.empty_positions.remove(pos)
            ttt.print_board()
            #print(ttt.empty_positions)
            if(ttt.is_winner(current_player, pos)):
                print(f'Player "{current_player}" has won!')
                ttt.winner = current_player
                break
            # swapping the turn can be done simply by XORing with 1.
            idx = idx ^ 1
    if (turn == 10 and ttt.winner == None):
        print('The game has tied!')

if __name__ == '__main__':
    ttt = TicTacToe()
    print("  TIC-TAC-TOE   ")
    print("Board positions:")
    #ttt.print_board()
    ttt.print_board_positions()
    print()
    
    start_playing(ttt)


